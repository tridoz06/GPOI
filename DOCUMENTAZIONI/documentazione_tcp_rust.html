<!DOCTYPE html>
<html lang="it">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Documentazione Codice Sorgente</title>

        <link rel="stylesheet" href="../CSS/documentazione.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css">
  
    </head>

    <body>

        <header>
            <h1>TCP in RUST</h1>
            <p>Una guida completa al codice sorgente e alle funzionalità del progetto.</p>
        </header>

        <nav>
            <ul>
                <li><a href="#teoria">Teoria del TCP</a></li>

                <li><a href="#code">Spiegazione del Codice</a></li>


            </ul>
        </nav>

        <section id="Teoria">
            <h2>Teoria del TCP</h2>
            <pre>
Il <b>Transmission Control Protocol (TCP)</b> è uno dei principali protocolli della suite di protocolli Internet (TCP/IP) ed è responsabile della <b>trasmissione affidabile dei dati tra applicazioni su reti di computer</b>. 
TCP fornisce una connessione orientata ai byte, che garantisce che i dati vengano consegnati in ordine e senza errori. In questa spiegazione, analizzeremo la <b>struttura dell'header TCP</b>, il processo di <b>three-way 
handshake</b>, il significato dei <b>numeri di sequenza</b> e di <b>acknowledgment</b>, e come TCP gestisce il <b>controllo degli errori</b>.




<h2>1. Header TCP</h2>
L'header TCP contiene informazioni cruciali per il corretto funzionamento del protocollo. È composto da vari campi, ciascuno dei quali ha un ruolo specifico. La struttura dell'header TCP è la seguente (dimensioni in bit):

    <b>- Porta di origine (16 bit):</b> specifica la porta dell'applicazione sorgente.
    <b>- Porta di destinazione (16 bit):</b> specifica la porta dell'applicazione di destinazione.
    <b>- Numero di sequenza (32 bit):</b> indica il numero del primo byte di dati in questo segmento. Questo numero è fondamentale per la gestione dell'ordine dei dati.
    <b>- Numero di acknowledgment (32 bit):</b> indica il numero di sequenza del prossimo byte che ci si aspetta di ricevere. Questo campo è utilizzato per riconoscere la ricezione di dati.
    <b>- Offset (4 bit):</b> indica la dimensione dell'header TCP, che consente al protocollo di sapere dove inizia i dati.
    <b>- Flag di controllo (6 bit):</b> contengono varie opzioni di controllo, come SYN (synchronize), ACK (acknowledge), FIN (finish), RST (reset), PSH (push), e URG (urgent).
    <b>- Finestra (16 bit):</b> indica la dimensione della finestra, che determina la quantità di dati che il mittente è disposto a ricevere.
    <b>- Checksum (16 bit):</b> utilizzato per il controllo degli errori. Calcola un valore di checksum sui dati dell'header e sui dati effettivi per verificare l'integrità dei dati durante la trasmissione.
    <b>- Urgent Pointer (16 bit):</b> se il flag URG è attivo, questo campo indica un punto nel flusso di dati che è considerato urgente.
    <b>- Opzioni (variabili):</b> campo utilizzato per opzioni aggiuntive, come la dimensione della finestra e il timestamp.




<h2>2. Three-Way Handshake</h2> 

Il processo di connessione TCP inizia con il three-way handshake, che stabilisce una <b>connessione affidabile tra il client e il server</b>. Questo processo avviene in tre fasi:

    <b>- SYN</b> il client invia un pacchetto SYN <b>(synchronize)</b> al server per richiedere l'apertura di una connessione. Questo pacchetto include il <b> numero di sequenza iniziale del client</b>.

    <b>- SYN-ACK:</b> il server riceve il pacchetto SYN e risponde con un pacchetto SYN-ACK <b>(synchronize-acknowledge)</b>. Questo pacchetto <b>conferma la ricezione del SYN dal client, include un proprio numero di sequenza 
                        iniziale e un acknowledgment del numero di sequenza del client (incrementato di 1)</b>.

    <b>- ACK:</b> infine, il client invia un pacchetto ACK <b>(acknowledge)</b> al server per confermare la ricezione del pacchetto SYN-ACK. A questo punto, la connessione è stabilita, e i due nodi <b>possono iniziare a scambiare dati</b>.




<h2>3. Sequence Number e Acknowledgment Number</h2>

Il numero di sequenza e il numero di acknowledgment sono due elementi <b>fondamentali</b> per il funzionamento di TCP:

    <b>- Numero di sequenza:</b> consente di <b>identificare l'ordine dei segmenti di dati</b>. Ogni byte di dati trasmesso in una connessione TCP ha un numero di sequenza univoco. 
                                            Quando un pacchetto viene ricevuto, il destinatario utilizza il numero di sequenza per <b>riordinare i dati se arrivano in disordine</b>.

    <b>- Numero di acknowledgment:</b> è un valore che indica il <b>numero di sequenza del prossimo byte che il destinatario si aspetta di ricevere</b>. Quando un pacchetto viene ricevuto, il destinatario invia un pacchetto di acknowledgment
                                                         al mittente con il numero di acknowledgment appropriato. Questo processo <b>conferma che i dati sono stati ricevuti correttamente e in ordine</b>.




<h2>4. Controllo degli Errori</h2>

TCP implementa diverse tecniche per garantire l'integrità dei dati trasmessi. Uno degli strumenti principali per il controllo degli errori è il <b>checksum</b>. Il checksum viene calcolato sui <b>dati dell'header e sui dati effettivi</b>, creando un valore 
che viene inviato insieme ai dati. Quando il destinatario riceve un pacchetto, <b>calcola nuovamente il checksum</b> e <b>confronta il valore calcolato con quello ricevuto</b>

    <b>- Se i due valori corrispondono:</b> i dati sono considerati integri.
    <b>- Se i valori non corrispondono:</b> il pacchetto è considerato corrotto e viene scartato. Il destinatario <b>non invia</b> alcun acknowledgment per quel pacchetto, e il mittente, non ricevendo l'acknowledgment entro un 
                                                             certo periodo di tempo, <b>ritenta l'invio del pacchetto</b>.

Inoltre, TCP utilizza meccanismi come il <b>timeout</b> e la <b>ritrasmissione dei pacchetti</b> per gestire la perdita di pacchetti e garantire che tutti i dati vengano trasmessi correttamente.

            </pre>
        </section>


        <section id="code">
            <h1>ESEMPI DI CODICE</h1>

            <section>
                <h2>LIBRERIE</h2>
                <pre>
                    <code class="language-rust">
/*
Serde è una libreria per la serializzazione e deserializzazione di dati in Rust. 
`Serialize` è un trait che consente di convertire strutture di dati in formati come JSON, 
mentre `Deserialize` consente di convertire formati di dati (come JSON) in strutture di dati Rust.
*/
use serde::{Deserialize, Serialize};

/*
Tokio è un framework asincrono per Rust. Questa libreria fornisce strumenti per la programmazione 
asincrona e basata su eventi. Le seguenti funzioni sono usate per la gestione di I/O e 
comunicazione di rete:
- `AsyncBufReadExt` fornisce metodi per la lettura di dati in modo asincrono da buffer.
- `UdpSocket` è utilizzato per la comunicazione tramite il protocollo UDP.
- `Mutex` è una struttura di sincronizzazione asincrona che consente l'accesso sicuro a risorse condivise.
- `timeout` è una funzione che permette di impostare un limite di tempo per l'esecuzione di operazioni asincrone.
*/
use tokio::io::AsyncBufReadExt;
use tokio::net::UdpSocket;
use tokio::sync::Mutex;
use tokio::time::timeout;

/*Rand è una libreria per generare numeri casuali in Rust. `Rng` è un trait che consente di generare 
numeri casuali di diversi tipi. Questa libreria è utile per applicazioni che necessitano di 
casualità, come giochi o simulazioni
*/.
use rand::Rng;

/*
Questa libreria standard fornisce funzioni e tipi per l'interazione con l'ambiente del sistema. 
`env` è utilizzato per accedere a variabili d'ambiente, mentre `io` è usato per operazioni di input/output.
*/
use std::env;
use std::io;

/*
`sync` fornisce tipi e strumenti per la programmazione concorrente, come `Arc`, 
che è un contatore di riferimenti atomico, utile per condividere dati tra thread in modo sicuro.
*/
use std::sync::Arc;

/*
Questa parte della libreria standard fornisce tipi per lavorare con il tempo e la durata.
`Instant` rappresenta un momento preciso nel tempo, mentre `Duration` rappresenta un intervallo di tempo.
use std::time::{Instant, Duration};

`mem` fornisce funzioni per manipolare la memoria, come la creazione e l'allocazione di 
variabili in modo efficiente.
*/
use std::mem;

/*
Crossterm è una libreria per creare interfacce a riga di comando (CLI) che supportano terminali 
cross-platform. Qui sono importate le funzionalità per gestire il cursore e le operazioni di terminale:
- `cursor` fornisce funzioni per controllare la posizione del cursore nel terminale.
- `execute` è usato per invocare comandi sul terminale, come il pulire lo schermo.
- `Clear` e `ClearType` sono utilizzati per cancellare il contenuto del terminale in vari modi.
*/
use crossterm::cursor;
use crossterm::{execute, terminal::{Clear, ClearType}};
                    </code>
                </pre>
            </section>

            <section>
                <h2>STRUCT PACKAGE</h2>
                <pre>
                    <code class="language-rust">
/*
Serve per dire al compilatore di implementare automaticamente i seguenti metodi per la struttura seguente:
- Debug: serve a poter stampare grazie al formato {:?} un'istanza della struttura per vedere in tempo reale i dati presenti in essa
- Serialize e Deserialize: servono per far si che la struttura possa essere convertita in JSON e viceversa, viene utilizzata per l'invio dei pacchetti
- Clone: dice il nome stesso che cosa fa, serve per poter clonare la struttua senza il rischio di passare riverimenti ad essa, ma creare un nuovo oggetto da 0
*/
#[derive(Debug, Serialize, Deserialize, Clone)]

/*
Struttura utilizzata per lo scambio dei pacchetti, contiene tutti i parametri principali del TCP. 
- source_port: la porta da cui il messaggio viene inviato
- destination_port: la porta a cui il messaggio deve arrivare
- source_ip_address: l'indirizzo ip di chi sta inviando il pacchetto
- destination_ip_address: l'indirizzo ip a cui il pacchetto deve arrivare
- window: parametro della connessione TCP che indica la dimensione massima del payload dei dati. 
- syn_flag: flag che serve a settare la richiesta di three_way_hand_shake
- fyn_flag: flag che serve a settare la richiesta di fine comunicazione
- sequence_number: parametro che serve come controllo degli errori per capire se sono stati persi dei messaggi e par la ricostruzione del messaggio nel caso sia frammentato
- ack_number: parametro per capire se dall'altra parte è arrivato tutto correttamente
- message: dati da inviare
- packate_size: la dimensione del pacchetto
- checksum: parametro per controllare che non ci siano errori nel messaggio 
*/
struct Packate {
    source_port: u16,
    destination_port: u16,
    source_ip_address: String,
    destination_ip_address: String,
    window: u16,
    syn_flag: u8,
    fyn_flag: u8,
    sequence_number: u32,
    ack_number: u32,
    message: String,
    packate_size: u32,
    checksum: u16,
}
                    </code>
                </pre>
            </section>

            <section>
                <h2>MAIN</h2>

                <section>
                    <h3>Gestione errore pulizia terminale</h3>
                    <pre>
                        <code class="language-rust">
/*
L'attributo `#[tokio::main]` indica che la funzione `main` sarà l'entry point dell'applicazione 
e utilizza il runtime asincrono di Tokio. Ciò consente di utilizzare operazioni asincrone all'interno 
della funzione `main`.
*/
#[tokio::main]
async fn main() {
    /*
    Prova a eseguire un comando per pulire il terminale. 
    `execute!` è una macro di Crossterm che permette di inviare comandi al terminale. 
    In questo caso, `Clear(ClearType::All)` indica che si desidera cancellare tutto il contenuto del terminale.
    */
    
    if let Err(err) = execute!(io::stdout(), Clear(ClearType::All)) {
        // Se c'è un errore durante la pulizia del terminale, lo stampo su stderr.
        eprintln!("Errore durante la pulizia del terminale: {}", err);
    }

    /*
    Prova a spostare il cursore all'inizio del terminale, alla posizione (0, 0).
    `cursor::MoveTo(0, 0)` specifica la posizione in cui il cursore deve essere spostato.
    */

    if let Err(err) = execute!(io::stdout(), cursor::MoveTo(0, 0)) {
        // Se c'è un errore durante lo spostamento del cursore, lo stampo su stderr.
        eprintln!("Errore durante lo spostamento del cursore: {}", err);
    }
                            
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Creazione Variabili Principali per dati pacchetto</h3>
                    <pre>
                        <code class="language-rust">

    /*
    variabile che serve per la gestione dell'input da tastiera.
    - String::new(): crea un oggetto stringa vuoto
    - Mutext::new(...): da la possibilità a più thread di gestire la risorsa passata all'interno 
    - Arc::new(...):rende la risorse che è è meglio siano immutabili Thread_Save, ovvero un solo accesso contemporaneamente
    */
    let shared_input = Arc::new(Mutex::new(String::new()));

    /*
    input_client è una clone sicuro del riferimento a shared_input, e server perchè dovremmo gestire 2 input diversi. utilizzereom shared_input per capire quando stiamo scrivendo da tastiera
    e input_client per leggere effettivamente cosa viene scritto in modo da poter  mandare il messaggio
    */
    let input_clone = Arc::clone(&shared_input);


    // waiting_time è una variabile che useremo durante il three_way_hand_shake per aspettare un numero preciso di secondi prima di ritentare la richiesta
    let waiting_time = Duration::from_secs(2);

    /*
    rng è una variabile che funziona come la classe random di Java, ovvero ritorna numeri casuali secondo un range dato. Questa viene utilizzata
    durante la creazione dei pacchetti per generare randomicamente la windows di ogni pacchetto e il suo rispettivo sequence number
    */
    let mut rng = rand::thread_rng();

    /*
    args è una variabile di tipo Vector di stringhe che utilizza la libreria "env" per prendere gli argomenti passati durante la fase di esecuzione del programma per settare le due porte 
    e volendo, nel caso il programma non funzioni in locale ma si voglia comunicare anche in remoto, si possono passare anche i due indirizzi ip.
    */
    let args: Vec<String> = env::args().collect();


    //le variabili my_ip e his_ip sono le variabili destinate alla creazione dle socket, a cui viene passato di base l'indirizzo di loopback, ovvero la macchina stessa
    let mut my_ip = String::from("127.0.0.1");
    let mut his_ip = String::from("127.0.0.1");

    //queste due variabili servono a tenere conto di quando ho iniziato l'attesa del messaggio e l'attesa del ACK, in modo da capire cosa devo rimandere, nel caso io debba farlo
    let mut start_time_for_receiving = Instant::now();
    let mut start_time_for_ack = Instant::now();
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Gestione ARGS</h3>
                    <pre>
                        <code class="language-rust">
    /*
    qua controllo che il numero di argomenti sia maggiore di 3, visto che l'argomento 0 è predefinito, e gli altri 2 devono essere obbligatoriamente le porte.
    nel caso il numero di argomenti sia maggiore di 3, i primi due argomenti saranno le porte, e gli altri 2 gli indirizzi IP. 
    */
    if args.len() < 3 {
        println!("ERRORE NELL'ESECUZIONE DEL PROGRAMMA, PASSARE LE PORTE COME ARGOMENTO");
        return;
    } else if args.len() > 3 {
        my_ip = args[3].clone();
        his_ip = args[4].clone();
    }

    /*
    qui faccio il parsing dei primi 2 argomenti per sapere da quale porta devo ricevere e a quale porta devo mandare. 
    Se il parsing va in errore il programma termina dopo aver stampato un messaggio di errore, altrimenti assegna il valore alla variabile
    */
    let my_port: u16 = match args[1].parse() {
        Ok(num) => num,
        Err(_) => {
            eprintln!("L'argomento non è un numero valido");
            return;
        }
    };

    let his_port: u16 = match args[2].parse() {
        Ok(num) => num,
        Err(_) => {
            eprintln!("L'argomento non è un numero valido");
            return;
        }
    };
                        
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Creazione variabili Package</h3>
                    <pre>
                        <code class="language-rust">
    /*
    in questa parte di codice creo i 2 pacchetti che mi servono e che andrò a modificare: il primo mi server per mandare, il secondo per ricevere. 
    Setto tutti i parametri a 0 tranne i 2 indirizzi_ip, le 2 porte, la 2 window, il sequence_number del pacchetto da mandare che viene generato random
    e il syn_flag del pacchetto da mandare perchè lo setto ad uno nel caso io voglia fare il three_way_hand_shake.
    */
    let mut packate_to_send = Packate {
        source_port: my_port,
        destination_port: his_port,
        source_ip_address: my_ip.clone(),
        destination_ip_address: his_ip.clone(),
        window: rng.gen_range(100..=200),
        syn_flag: 1,
        fyn_flag: 0,
        sequence_number: rng.gen_range(100..=1000),
        ack_number: 0,
        message: String::new(),
        packate_size: 0,
        checksum:0,
    };

    let mut packate_to_receive = Packate {
        source_port: his_port,
        destination_port: my_port,
        source_ip_address: his_ip.clone(),
        destination_ip_address: my_ip.clone(),
        window: rng.gen_range(100..=200),
        syn_flag: 0,
        fyn_flag: 0,
        sequence_number: 0,
        ack_number: 0,
        message: String::new(),
        packate_size: 0,
        checksum:0,
    };
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Creazione variabili principali per comunicazione</h3>
                    <pre>
                        <code class="language-rust">
/*
`tokio::spawn` avvia un nuovo task asincrono nel runtime di Tokio. Questo permette di eseguire operazioni in modo concorrente 
senza bloccare il thread principale dell'applicazione.

`async move` indica che la chiusura che segue è asincrona e che tutte le variabili utilizzate all'interno di essa saranno trasferite
nel contesto della chiusura. Questo garantisce che non ci siano conflitti di proprietà.

Chiama la funzione asincrona `handle_keyboard_input` passando `input_clone` come argomento. L'uso di `.await` significa che
l'esecuzione di questa chiusura sarà sospesa fino a quando `handle_keyboard_input` non avrà completato la sua esecuzione.
*/
tokio::spawn(async move {   handle_keyboard_input(input_clone).await;
});
                            
    //variabile di tipo UdpSocket utilizzata per rivecere ed inviare dati. viene creato passando my_ip e my_port che vengono formattati  nel formato my_ip:my_port
    let socket = UdpSocket::bind(format!("{}:{}", my_ip, my_port)).await.unwrap();

    //variabile di tipo stringa che serve ad indicare la destinazione a cui inviare i pacchetti e da cui riceverli. 
    let destination = format!("{}:{}", his_ip, his_port);

    //questa è la dimensione minima del paccheto in byte, contanto tutti i parametri essendo vuoti, mi server per calcolare il sequence number.
    let dimensiome_minima_pacchetto:u32 = 26;

    /*
    Queste 2 variabili sono due vettori di tipo pacchtto, che mi servono a tenere conto di messaggi che mi sono arrivati e che ho inviato.

    mi server tenere conto dei messaggi chi ho inviato per poter reinviare il buffer, nel caso alcuni messaggi non siano arrivati correttamente ed io abbia bisogni di reinviarli.

    Ho invece bisogno di sapere quali messaggi mi sono già arrivai per calcolare correttamente il sequence_number e quindi l'ack number da rimandare nel caso mi sia stato 
    reinviato il buffer, in modo da con contare pacchetti duplicati. 
    */
    let mut memory_of_packate: Vec<Packate> = Vec::new();
    let mut recevied_packates: Vec<Packate> = Vec::new();

    //buf è una variabile che mi server per ricevere i pacchetti che mi vengono inviati sotto forma di JSON per poi poterli Deserializzare in una variabile di tipo Packate.
    let mut buf = [0u8; 1024];

    //serialized data è la varaibile che manderò, visto che contiene il pacchetto serializzato in JSON, quindi sotto forma di stringa. 
    let mut serialized_data = bincode::serialize(&packate_to_send).expect("Failed to serialize");

    //variabile che mi serve per tenere conto se è stato fatto il three_way_hand_shake, così da poter iniziare normalmente la comunicazione.
    let mut done_three_way_hand_shake: u8 = 0;

    /*
    queste 3 varibili servono a tenere conto dei vari sequence number:
    - initial sequence number è settato a 0 perchè non è ancora stato utilizzato
    - expected_sequence_number è il sequence number che mi aspetto di trovare nel pacchetto che ricevo, così vuol dire che non ci sono stati errori nella comunicazione
    - current_sequence_number è il mio sequence number corrente, quello che devo inviare, e viene settato al sequence number generato casualmente in packate_to_send
    */
    let mut initial_sequence_number:u32 = 0;
    let mut expected_sequence_number:u32 = 0;
    let mut current_sequence_number: u32 = packate_to_send.sequence_number;

                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Main loop</h3>

                    <section>
                        <h4>Select</h4>

                        <section>
                            <h5>Input dal Socket</h5>
                                <pre>
                                    <code class="language-rust">

loop {
    // Inizia un ciclo infinito per gestire la ricezione di pacchetti.
    tokio::select! {
        // Utilizza la macro select di Tokio per attendere diversi eventi in modo concorrente.
        
        result = socket.recv_from(&mut buf) => {
            // Aspetta di ricevere dati dal socket UDP e memorizza il risultato in `result`.
            
            match result {
                Ok((size, _)) => {
                    // Se la ricezione ha successo, deserializza i dati ricevuti.
                    packate_to_receive = bincode::deserialize(&buf[..size]).expect("failed to deserialize");
                    // Aggiorna il tempo di inizio per la ricezione.
                    start_time_for_receiving = Instant::now();
                    // Incrementa il numero di sequenza previsto in base alla dimensione del pacchetto ricevuto.
                    expected_sequence_number += packate_to_receive.packate_size;
                }
                Err(e) => {
                    // Gestisce eventuali errori durante la ricezione, stampando l'errore.
                    eprintln!("Errore durante la ricezione dei dati UDP: {}", e);
                }
            }

            // Controlla se il pacchetto ricevuto contiene il flag SYN (synchronize).
            if packate_to_receive.syn_flag == 1 {
                // Se il pacchetto è un SYN, aggiorna il numero di sequenza previsto con il numero di sequenza del pacchetto ricevuto.
                expected_sequence_number = packate_to_receive.sequence_number;
                // Inizia la funzione per il three_way_hand_shake, passando i parametri necessari.
                receiving_three_way_handshake(&socket, &destination, waiting_time, &mut packate_to_send, &mut packate_to_receive, &mut done_three_way_hand_shake, &mut initial_sequence_number).await;
            }
            // Controlla se il pacchetto ricevuto è un ACK (acknowledgment) per il numero di sequenza corrente.
            else if packate_to_receive.ack_number == current_sequence_number {
                // Se l'ACK è stato ricevuto, stampa un messaggio di conferma.
                println!("\nACK RICEVUTO SUI MESSAGGI PRECEDENTI\n");
                // Pulisce la memoria dei pacchetti precedentemente ricevuti.
                memory_of_packate.clear();
                // Aggiorna il tempo di inizio per la ricezione degli ACK.
                start_time_for_ack = Instant::now();
            } 
            // Se il pacchetto non è né SYN né ACK, viene aggiunto a una lista di pacchetti ricevuti.
                else {
                    recevied_packates.push(packate_to_receive.clone());
                }
            }

                                        
                                    </code>
                                </pre>
                            
                        </section>

                        <section>
                            <h5>Input da tastiera</h5>
                                <pre>
                                    <code class="language-rust">
    // Attende per 100 millisecondi prima di eseguire il codice seguente.
    _ = tokio::time::sleep(std::time::Duration::from_millis(100)) => {
        // Blocca l'accesso all'input condiviso per garantire l'esclusione mutua.
        let mut input = shared_input.lock().await;
        
        // Verifica se ci sono dati nell'input.
        if !input.is_empty() {
            // Controlla se il handshake a tre vie è completato.
            if done_three_way_hand_shake == 0 {
                // Se non è completato, impostalo come completato e inizia il processo di trasmissione.
                done_three_way_hand_shake = 1;
                transmitting_three_way_handshake(&socket, &destination, waiting_time, &mut packate_to_send, &mut packate_to_receive, &mut initial_sequence_number).await;
            } else {
                // Aggiorna il tempo di inizio per la ricezione degli ACK.
                start_time_for_ack = Instant::now();
                // Clona il messaggio dall'input condiviso nel pacchetto da inviare.
                packate_to_send.message = input.clone();
                // Imposta il flag SYN a 0 (indicando che non si tratta di un pacchetto di sincronizzazione).
                packate_to_send.syn_flag = 0;
    
                // Controlla se la lunghezza del messaggio è minore o uguale a 10 caratteri.
                if packate_to_send.message.len() <= 10 {
                    // Calcola la dimensione del pacchetto in base ai dati del pacchetto.
                    packate_to_send.packate_size = dimensiome_minima_pacchetto + 
                        packate_to_send.source_ip_address.len() as u32 + 
                        packate_to_send.destination_ip_address.len() as u32 + 
                        packate_to_send.message.len() as u32;
    
                    // Imposta il numero di ACK e il numero di sequenza per il pacchetto da inviare.
                    packate_to_send.ack_number = 0;
                    packate_to_send.sequence_number = current_sequence_number;
                    // Incrementa il numero di sequenza attuale in base alla dimensione del pacchetto.
                    current_sequence_number += packate_to_send.packate_size;
    
                    // Serializza il pacchetto da inviare in formato binario.
                    serialized_data = bincode::serialize(&packate_to_send).expect("Failed to serialize");
                    // Invia il pacchetto serializzato al socket.
                    socket.send_to(&serialized_data, destination.clone()).await.expect("failed to send");
                    // Memorizza il pacchetto nella memoria dei pacchetti.
                    memory_of_packate.push(packate_to_send.clone());
    
                } else {
                    // Se il messaggio è più lungo di 10 caratteri, gestisci il messaggio tramite la funzione di splitting.
                    split_string(&mut packate_to_send, &destination, &mut memory_of_packate, &socket, &mut current_sequence_number).await;
                }
    
                // Resetta l'input condiviso per prepararlo per nuove informazioni.
                *input = String::new();
            }
        }
    }


}                                       
                                    </code>
                                </pre>
                            
                        </section>

                    </section>

                    <section>
                        <h4>Controlli controllo su cosa rimandare</h4>
                        
                        <section>
                            <h5>Mando ACK</h5>
                            <pre>
                                <code class="language-rust">
    // Calcola il tempo trascorso dalla ricezione dei pacchetti.
    let end_time_for_receiving = start_time_for_receiving.elapsed();
    // Calcola il tempo trascorso dalla ricezione dell'ACK.
    let end_time_for_ack = start_time_for_ack.elapsed();

    // Controlla se sono passati 5 secondi dalla ricezione e se ci sono pacchetti ricevuti.
    if end_time_for_receiving.as_secs() >= 5 && recevied_packates.len() > 0 {
        // Stampa i messaggi ricevuti e verifica se non ci sono errori.
        if print_messages(&mut recevied_packates).await == 0 {
            // Se i messaggi sono stati stampati correttamente, prepara un pacchetto di ACK.
            packate_to_send.message = String::from(""); // Imposta il messaggio dell'ACK a vuoto.
            packate_to_send.ack_number = expected_sequence_number; // Imposta il numero di ACK al numero di sequenza previsto.
            
            // Serializza il pacchetto di ACK in formato binario.
            serialized_data = bincode::serialize(&packate_to_send).expect("failed to serialize");
            // Invia il pacchetto di ACK al destinatario.
            socket.send_to(&serialized_data, destination.clone()).await.expect("failed to send ack back");
            
            // Ripristina il numero di ACK per preparare il pacchetto per futuri invii.
            packate_to_send.ack_number = 0;
            // Resetta il timer per la ricezione dei pacchetti.
            start_time_for_receiving = Instant::now();
        }
    }

                            
                                </code>
                            </pre>
                        </section>

                        <section>
                            <h5>Rimando Buffer perchè c'è stato un errore</h5>
                            <pre>
                                <code class="language-rust">
// Controlla se sono trascorsi 10 secondi dall'ultimo ACK e se ci sono pacchetti nella memoria.
if end_time_for_ack.as_secs() >= 10 && memory_of_packate.len() > 0 {
    // Se le condizioni sono soddisfatte, stampa un messaggio per indicare che si sta rimandando il buffer.
    println!("\nRIMANDO BUFFER\n");
    // Chiama la funzione `send_buffer` per inviare i pacchetti memorizzati.
    send_buffer(&socket, &destination, &mut memory_of_packate).await;
    // Ripristina il timer per la ricezione degli ACK.
    start_time_for_ack = Instant::now();
}
                                    
                                </code>
                            </pre>
                        </section>
                    </section>



                </section>

            </section>

            <section>
                <h2>Funzioni</h2>

                <section>
                    <h3>Send Buffer</h3>
                    <pre>
                        <code class="language-rust">
// Definisce una funzione asincrona per inviare un buffer di pacchetti attraverso un socket UDP.
async fn send_buffer(socket: &tokio::net::UdpSocket, destination: &String, mem: &mut Vec<Packate>) {
    // Itera su ogni pacchetto nella memoria (buffer).
    for i in 0..mem.len() {
        // Serializza il pacchetto corrente in formato binario utilizzando bincode.
        let serialized_data = bincode::serialize(&mem[i]).expect("failed to serialize");
        // Invia il pacchetto serializzato al destinatario attraverso il socket.
        socket.send_to(&serialized_data, destination.clone()).await.expect("failed to send");
    }
}
                            
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Calculate Checksum</h3>
                    <pre>
                        <code class="language-rust">
// Funzione asincrona per calcolare il checksum di un pacchetto.
async fn calculate_checksum(packate_to_calculate_checksum: &mut Packate) {
    // Serializza il pacchetto in formato binario.
    let data = bincode::serialize(packate_to_calculate_checksum).expect("failed to serialize");
    let mut sum: u32 = 0; // Inizializza la somma del checksum a zero.

    // Itera sui dati serializzati a coppie di byte.
    for i in (0..data.len()).step_by(2) {
        // Combina due byte in un word a 16 bit.
        let word = (data[i] as u16) << 8 | (data[i + 1] as u16);
        // Aggiunge il word alla somma del checksum.
        sum += word as u32;
    }

    // Se il numero di byte è dispari, aggiunge l'ultimo byte.
    if data.len() % 2 != 0 {
        sum += (data[data.len() - 1] as u16) as u32;
    }

    // Riduce la somma a 16 bit se ci sono overflow.
    while sum >> 16 != 0 {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    // Imposta il checksum del pacchetto come complemento a uno della somma finale.
    packate_to_calculate_checksum.checksum = !(sum as u16) as u16;
}
                            
                            
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Handle Keyboard Input</h3>
                    <pre>
                        <code class="language-rust">
// Funzione asincrona per gestire l'input da tastiera e aggiorna una stringa condivisa.
async fn handle_keyboard_input(shared_input: Arc<Mutex<String>>) {
    // Ciclo infinito per continuare a leggere l'input da tastiera.
    loop {
        // Ottiene un riferimento allo standard input di Tokio.
        let stdin = tokio::io::stdin();
        // Crea un lettore buffered per gestire l'input.
        let mut reader = tokio::io::BufReader::new(stdin);

        let mut line = String::new(); // Variabile per memorizzare la linea letta.
        // Legge una riga dall'input standard.
        if let Ok(_) = reader.read_line(&mut line).await {
            // Se la lettura ha successo, acquisisce il lock sulla stringa condivisa.
            let mut input = shared_input.lock().await;
            // Aggiorna il valore della stringa condivisa con la riga letta.
            *input = line;
        } else {
            // Se si verifica un errore durante la lettura, stampa un messaggio di errore.
            eprintln!("Errore durante la lettura dell'input dalla tastiera");
        }
    }
}
                            

                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Receiving Three Way Handshake</h3>
                    <pre>
                        <code class="language-rust">
// Funzione asincrona per gestire il processo di handshake a tre vie per la sincronizzazione.
async fn receiving_three_way_handshake(socket: &tokio::net::UdpSocket, destination: &String, waiting_time: Duration, packate_to_send: &mut Packate, packate_to_receive: &mut Packate, done_three_way_hand_shake: &mut u8, initial_sequence_number: &mut u32 ) {
    // Imposta il flag SYN per indicare l'inizio del handshake.
    packate_to_send.syn_flag = 1;
    // Imposta il numero di ack come il numero di sequenza ricevuto + 1.
    packate_to_send.ack_number = packate_to_receive.sequence_number + 1;
    println!("RICEVUTO MESSAGGIO DI RICHIESTA SINCRONIZZAZIONE, MANDO ACK...");
    
    // Salva il numero di sequenza iniziale per future comunicazioni.
    *initial_sequence_number = packate_to_receive.sequence_number;

    // Serializza il pacchetto da inviare.
    let serialized_data = bincode::serialize(&packate_to_send).expect("failed to serialize");
    // Invia il pacchetto serializzato al destinatario.
    socket.send_to(&serialized_data, destination.clone()).await.expect("failed to send");

    let mut buf = [0; 1024]; // Buffer per ricevere i dati.
    // Attendi la ricezione dell'ACK finché non viene ricevuto o il numero di sequenza non corrisponde.
    while packate_to_receive.ack_number != packate_to_send.sequence_number + 1 {
        match timeout(waiting_time, socket.recv_from(&mut buf)).await {
            // Ricezione di dati.
            Ok(result) => match result {
                Ok((size, _source)) => {
                    // Deserializza il pacchetto ricevuto e aggiorna il pacchetto da ricevere.
                    *packate_to_receive = bincode::deserialize(&buf[..size]).unwrap();
                    break; // Esci dal ciclo una volta ricevuto un pacchetto valido.
                }
                // Nessun dato disponibile, continua con il ciclo.
                Err(_e) => {}
            },

            // Timeout, stampa un messaggio di avviso.
            Err(_e) => {
                println!("NESSUNA RISPOSTA RICEVUTA...\n");
            }
        }
    }

    // Conferma che l'ACK è stato ricevuto e che il handshake è completato.
    println!("ACK RICEVUTO, PROCEDO ALLA COMUNICAZIONE...");
    packate_to_send.syn_flag = 0; // Disabilita il flag SYN per la comunicazione.
    *done_three_way_hand_shake = 1; // Segna che l'handshake è completato.
}


println!("ACK RICEVUTO, PROCEDO ALLA COMUNICAZIONE...");
packate_to_send.syn_flag = 0;
*done_three_way_hand_shake = 1;
}
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Transmitting Three Way Handshake</h3>
                    <pre>
                        <code class="language-rust">
// Funzione asincrona per gestire la trasmissione del processo di handshake a tre vie.
async fn transmitting_three_way_handshake(socket: &tokio::net::UdpSocket, destination: &String, waiting_time: Duration, packate_to_send: &mut Packate, packate_to_receive: &mut Packate, initial_sequence_number: &mut u32 ) {
    // Imposta il flag SYN per indicare l'inizio dell'handshake.
    packate_to_send.syn_flag = 1;

    let mut buf = [0; 1024]; // Buffer per ricevere i dati.
    // Serializza il pacchetto da inviare.
    let serialized_data = bincode::serialize(&packate_to_send).expect("failed to serialize");

    // Invia il pacchetto SYN finché non riceviamo una conferma (ACK) dal destinatario.
    while packate_to_receive.syn_flag == 0 {
        // Invia il pacchetto di sincronizzazione al destinatario.
        socket.send_to(&serialized_data, destination).await.expect("Failed to send SYN packet");
        println!("INVIO PACCHETTO DI SINCRONIZZAZIONE...");

        // Aspetta di ricevere una risposta o il timeout.
        match timeout(waiting_time, socket.recv_from(&mut buf)).await {
            Ok(result) => match result {
                Ok((size, _source)) => {
                    // Deserializza il pacchetto ricevuto e aggiorna il pacchetto da ricevere.
                    *packate_to_receive = bincode::deserialize(&buf[..size]).unwrap();
                    break; // Esci dal ciclo una volta ricevuto un pacchetto valido.
                }

                // Nessun dato disponibile, continua con il ciclo.
                Err(_e) => {}
            },

            // Timeout, stampa un messaggio di avviso.
            Err(_e) => {
                println!("NESSUNA RISPOSTA RICEVUTA...\n");
            }
        }
    }

    // Conferma che l'ACK è stato ricevuto.
    println!("RICEVUTA CONFERMA DI ACK PER IL MIO MESSAGGIO, RISPONDO CON ACK PER CONFERMARE...");
    *initial_sequence_number = packate_to_receive.sequence_number; // Salva il numero di sequenza ricevuto.

    // Prepara il pacchetto ACK da inviare.
    packate_to_send.syn_flag = 0; // Disabilita il flag SYN.
    packate_to_send.ack_number = packate_to_receive.sequence_number + 1; // Imposta il numero di ack atteso.
    packate_to_send.sequence_number = 0; // Reset del numero di sequenza.

    // Serializza il pacchetto ACK da inviare.
    let serialized_data = bincode::serialize(&packate_to_send).expect("failed to serialize");

    // Invia il pacchetto ACK al destinatario.
    socket.send_to(&serialized_data, destination).await.expect("Failed to send ACK packet");
}
                            
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Split string</h3>
                    <pre>
                        <code class="language-rust">
async fn split_string(to_send: &mut Packate, dest: &String, memory: &mut Vec<Packate>, sock: &tokio::net::UdpSocket, sn: &mut u32) {
    // Crea una copia del pacchetto originale da inviare.
    let mut sub_pack = to_send.clone();
    // Clona il messaggio originale in una variabile locale per la suddivisione.
    let s = sub_pack.message.clone();
    // Definisce la dimensione minima del pacchetto da inviare.
    let dimensiome_minima_pacchetto: u32 = 26;
    // Inizializza l'indice di partenza per la suddivisione del messaggio.
    let mut start = 0;

    // Ciclo per suddividere il messaggio fino a quando non sono stati elaborati tutti i caratteri.
    while start < s.len() {
        // Calcola l'indice finale per la sottostringa, garantendo di non superare la lunghezza del messaggio.
        let end = (start + 10).min(s.len());

        // Imposta il messaggio del pacchetto attuale come sottostringa del messaggio originale.
        sub_pack.message = s[start..end].to_string();
        // Imposta il numero di sequenza corrente per il pacchetto.
        sub_pack.sequence_number = *sn;
        // Calcola la dimensione totale del pacchetto, inclusi gli indirizzi IP e la lunghezza del messaggio.
        sub_pack.packate_size = dimensiome_minima_pacchetto 
            + sub_pack.destination_ip_address.len() as u32 
            + sub_pack.source_ip_address.len() as u32 
            + sub_pack.message.len() as u32;
        // Aggiorna il numero di sequenza per il prossimo pacchetto.
        *sn += sub_pack.packate_size;

        // Aggiunge il pacchetto creato alla memoria per eventuali operazioni di ri-invio o gestione.
        memory.push(sub_pack.clone());

        // Serializza il pacchetto per l'invio tramite UDP.
        let serialized = bincode::serialize(&sub_pack).expect("Failed to serialize");
        // Invia il pacchetto serializzato al destinatario.
        sock.send_to(&serialized, dest.clone()).await.expect("failed to send");

        // Aggiorna l'indice di partenza per la prossima iterazione del ciclo.
        start = end;
    }
}
                            
                        </code>
                    </pre>
                </section>

                <section>
                    <h3>Print messages</h3>
                    <pre>
                        <code class="language-rust">
async fn print_messages(vec: &mut Vec<Packate>) -> u8 {
    // Ottiene la lunghezza del vettore di pacchetti.
    let len = vec.len();

    // Ordina i pacchetti in base al numero di sequenza utilizzando l'algoritmo Bubble Sort.
    for i in 0..len {
        for j in 0..len - i - 1 {
            if vec[j].sequence_number > vec[j + 1].sequence_number {
                vec.swap(j, j + 1);
            }
        }
    }

    // Controlla la sequenza dei pacchetti per assicurarsi che non ci siano buchi.
    for i in 0..len - 1 {
        // Verifica se il numero di sequenza del pacchetto successivo corrisponde al numero di sequenza del pacchetto corrente più la sua dimensione.
        if (vec[i].sequence_number + vec[i].packate_size) != vec[i + 1].sequence_number {
            // Se si trova un errore, svuota il vettore e stampa un messaggio di errore.
            vec.clear();
            println!("\ntrovato errore nella sequenza dei pacchetti");
            return 255; // Restituisce un codice di errore.
        }
    }

    // Stampa i messaggi dei pacchetti ordinati.
    for packate in &mut *vec {
        print!("{}", packate.message);
    }
    // Svuota il vettore di pacchetti dopo la stampa.
    vec.clear();
    return 0; // Restituisce 0 per indicare successo.
}
                            
                        </code>
                    </pre>
                </section>


            </section>



        </section>


        <footer>
            <p>
                &copy;   TPC in RUST<br>
                Tridapali Leonardo - Concaro Davide<br>
                4BIIN A.S. 2023/2024
            </p>
        </footer>

        <script src="../JS/documentazione.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>

    </body>
</html>
